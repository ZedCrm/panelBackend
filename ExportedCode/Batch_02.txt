===== FILE: App\Object\Base\CrudService.cs =====
using App.utility;
using AutoMapper;
using Domain.Objects;
using MyFrameWork.AppTool;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Threading.Tasks;

namespace App.Object.Base
{
    public abstract class CrudService<TEntity, TDto, TCreate, TUpdate, TKey>
        where TEntity : BaseDomain
        where TDto : class
        where TCreate : class
        where TUpdate : class
    {
        protected readonly IBaseRep<TEntity, TKey> _repo;
        protected readonly IMapper _mapper;

        protected CrudService(IBaseRep<TEntity, TKey> repository, IMapper mapper)
        {
            _repo = repository;
            _mapper = mapper;
        }

        public virtual async Task<ApiResult<List<TDto>>> GetAllAsync(Pagination pagination)
        {
            var entities = await _repo.GetAsync(pagination);
            var data   = _mapper.Map<List<TDto>>(entities);
            var total  = await _repo.CountAsync();
            return ApiResult<List<TDto>>.PagedSuccess(data, total, pagination.PageNumber, pagination.PageSize);
        }

        public virtual async Task<ApiResult<TUpdate>> GetByIdAsync(TKey id)
        {
            var entity = await _repo.GetAsync(id);
            return entity == null
                ? ApiResult<TUpdate>.Failed(MessageApp.NotFound, 404)
                : ApiResult<TUpdate>.Success(_mapper.Map<TUpdate>(entity));
        }

        public virtual async Task<ApiResult> CreateAsync(TCreate dto)
        {
            var validation = ModelValidator.ValidateToOpt(dto);
            if (!validation.IsSucceeded) return ApiResult.Failed(validation.Message);

            var entity = _mapper.Map<TEntity>(dto);
            await _repo.CreateAsync(entity);
            await _repo.SaveChangesAsync();
            return ApiResult.Success(MessageApp.CustomSuccess("Ø§ÙØ²ÙˆØ¯Ù†"));
        }

        public virtual async Task<ApiResult> UpdateAsync(TUpdate dto)
        {
            var validation = ModelValidator.ValidateToOpt(dto);
            if (!validation.IsSucceeded) return ApiResult.Failed(validation.Message);

            var id = (TKey)typeof(TUpdate).GetProperty("Id")!.GetValue(dto)!;
            var entity = await _repo.GetAsync(id);
            if (entity == null) return ApiResult.Failed(MessageApp.NotFound, 404);

            _mapper.Map(dto, entity);
            await _repo.UpdateAsync(entity);
            await _repo.SaveChangesAsync();
            return ApiResult.Success(MessageApp.CustomSuccess("ÙˆÛŒØ±Ø§ÛŒØ´"));
        }

        public virtual async Task<ApiResult> DeleteAsync(List<TKey> ids)
        {
            if (ids == null || !ids.Any()) return ApiResult.Failed("Ù‡ÛŒÚ† Ø´Ù†Ø§Ø³Ù‡â€ŒØ§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.");

            var entities = await _repo.GetByIdsAsync(ids);
            var deletable = new List<TEntity>();
            var used = new List<TEntity>();

            foreach (var e in entities)
            {
                var hasRel = await _repo.HasRelationsAsync(e);
                (hasRel ? used : deletable).Add(e);
            }

            if (deletable.Any())
            {
                _repo.DeleteRange(deletable);
                await _repo.SaveChangesAsync();
            }

            var msg = "";
            if (deletable.Count > 0) msg += $"{deletable.Count} Ø±Ú©ÙˆØ±Ø¯ Ø­Ø°Ù Ø´Ø¯. ";
            if (used.Count > 0) msg += $"{used.Count} Ù…ÙˆØ±Ø¯ Ø¨Ù‡ Ø¯Ù„ÛŒÙ„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø­Ø°Ù Ù†Ø´Ø¯.";

            return ApiResult.Success(msg.Trim());
        }
    }
}

===== FILE: App\Object\Base\IPersonRep.cs =====
using Domain.Objects.Base;

namespace App.Object.Base
{
    public interface IPersonRep : IBaseRep<Person, int>
    {

    }
}


===== FILE: App\Object\Base\PersonApp.cs =====
using App.Contracts.Object.Base;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace App.Object.Base
{
    public class PersonApp : IPersonApp
    {
        private readonly IPersonRep _ctx;
        public PersonApp(IPersonRep personRep)
        {
            _ctx = personRep;
        }
        public async Task<List<PersonView>> personViews()
        {
            var persons = await _ctx.GetAsync();

            return  persons.Select(c => new PersonView
            {
                Id = c.Id,
                Name = c.Name,
                Family = c.Family,
                age = c.Age,

            }).ToList();

        }

        public Task<List<PersonView>> PersonViews()
        {
            throw new NotImplementedException();
        }
    }
}


===== FILE: App\Object\Chat\MessageApp\IMessageRep.cs =====
// ConfApp/Rep/Chat/IMessageRep.cs
using App;
using Domain.Objects.Chat;
using MyFrameWork.AppTool;

namespace App.Object.Chat.MessageApp

{
    public interface IMessageRep : IBaseRep<Message, int>
    {
        Task<List<Message>> GetChatHistoryAsync(int userId, int otherUserId, Pagination pagination);
        Task<int> GetUnreadCountAsync(int receiverId, int senderId);
        Task MarkAsReadAsync(int receiverId, int senderId);
    }
}

===== FILE: App\Object\Chat\ChatApp.cs =====
// App/Object/Chat/ChatApp.cs
using App.Contracts.Object.Chat;
using App.Object.Base.Users;
using App.Object.Chat.MessageApp;
using App.utility;
using AutoMapper;
using MyFrameWork.AppTool;
using Domain.Objects.Base;
using Domain.Objects.Chat;
using SixLabors.ImageSharp.Processing;

namespace App.Object.Chat
{
    public class ChatApp : IChatApp
    {
        private readonly IMessageRep _messageRep;
        private readonly IMyUserRepository _userRep;
        private readonly IFileService _fileService;
        private readonly IMapper _mapper;
        private readonly UserStatusService _statusService;

        public ChatApp(
            IMessageRep messageRep,
            IMyUserRepository userRep,
            IFileService fileService,
            IMapper mapper,
            UserStatusService statusService)
        {
            _messageRep = messageRep;
            _userRep = userRep;
            _fileService = fileService;
            _mapper = mapper;
            _statusService = statusService;
        }

        public async Task<ApiResult<MessageView>> SendMessageAsync(SendMessageDto dto, int senderId)
        {
            var receiver = await _userRep.GetAsync(dto.ReceiverId);
            if (receiver == null)
                return ApiResult<MessageView>.Failed("Ú¯ÛŒØ±Ù†Ø¯Ù‡ ÛŒØ§ÙØª Ù†Ø´Ø¯.", 404);

            var message = new Message
            {
                SenderId = senderId,
                ReceiverId = dto.ReceiverId,
                Content = dto.Content,
                Type = dto.Type,
                SentAt = DateTime.Now,
                DeliveredAt = DateTime.Now
            };

            if (dto.File != null)
            {
                var resize = dto.Type == MessageType.Image
                    ? new ResizeOptions { Size = new(800, 800), Mode = ResizeMode.Max }
                    : null;

                message.FileUrl = await _fileService.UploadAsync(
                    dto.File, "uploads/chat", null, resize);
            }

            await _messageRep.CreateAsync(message);
            await _messageRep.SaveChangesAsync();

            var view = _mapper.Map<MessageView>(message);
            view.SenderName = (await _userRep.GetAsync(senderId))?.FullName ?? "Ù…Ù†";
            view.IsMine = true;

            return ApiResult<MessageView>.Success(view, "Ù¾ÛŒØ§Ù… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.");
        }

        public async Task<ApiResult<List<MessageView>>> GetChatHistoryAsync(int otherUserId, Pagination pagination, int currentUserId)
        {
            var messages = await _messageRep.GetChatHistoryAsync(currentUserId, otherUserId, pagination);
            var views = _mapper.Map<List<MessageView>>(messages);

            var currentUser = await _userRep.GetAsync(currentUserId);
            var otherUser = await _userRep.GetAsync(otherUserId);

            foreach (var v in views)
            {
                v.SenderName = v.SenderId == currentUserId 
                    ? currentUser?.FullName ?? "Ù…Ù†" 
                    : otherUser?.FullName ?? "Ú©Ø§Ø±Ø¨Ø± Ù†Ø§Ø´Ù†Ø§Ø³";
                v.IsMine = v.SenderId == currentUserId;
            }

            return ApiResult<List<MessageView>>.Success(views);
        }

        public async Task<ApiResult<List<ChatListItem>>> GetChatListAsync(int userId)
        {
            var sent = await _messageRep.GetFilteredAsync(m => m.SenderId == userId);
            var received = await _messageRep.GetFilteredAsync(m => m.ReceiverId == userId);

            var allMessages = sent.Concat(received);

            var grouped = allMessages
                .GroupBy(m => m.SenderId == userId ? m.ReceiverId : m.SenderId)
                .Select(g =>
                {
                    var lastMsg = g.OrderByDescending(m => m.SentAt).First();
                    var (status, lastSeen) = _statusService.GetStatus(g.Key);

                    return new ChatListItem
                    {
                        UserId = g.Key,
                        UserName = "Ú©Ø§Ø±Ø¨Ø±", // Ø¨Ø¹Ø¯Ø§Ù‹ Ø¨Ø§ join ÙˆØ§Ù‚Ø¹ÛŒ
                        LastMessage = lastMsg.Content,
                        LastMessageTime = lastMsg.SentAt,
                        UnreadCount = g.Count(m => 
                            m.ReceiverId == userId && 
                            m.SeenAt == null && 
                            !m.IsDeletedForReceiver),
                        IsOnline = status == UserStatus.Online,
                        LastSeen = lastSeen
                    };
                })
                .ToList();

            return ApiResult<List<ChatListItem>>.Success(grouped);
        }

        public async Task<ApiResult> MarkAsReadAsync(int senderId, int receiverId)
        {
            await _messageRep.MarkAsReadAsync(receiverId, senderId);
            await _messageRep.SaveChangesAsync();
            return ApiResult.Success("Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ø®ÙˆØ§Ù†Ø¯Ù‡â€ŒØ´Ø¯Ù‡ Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø´Ø¯Ù†Ø¯.");
        }

        public async Task<ApiResult<int>> GetUnreadCountAsync(int receiverId)
        {
            var count = await _messageRep.GetUnreadCountAsync(receiverId, 0);
            return ApiResult<int>.Success(count);
        }

        public async Task<ApiResult<int>> GetTotalUnreadCountAsync(int receiverId)
        {
            var unreadMessages = await _messageRep.GetFilteredAsync(m =>
                m.ReceiverId == receiverId &&
                m.SeenAt == null &&
                !m.IsDeletedForReceiver
            );

            return ApiResult<int>.Success(unreadMessages.Count);
        }
    }
}

===== FILE: App\Object\Shop\CountTypeApp\ContTypeApp.cs =====
using App.Contracts.Object.Shop.CountTypeCon;
using App.Object.Base;
using App.utility;
using AutoMapper;
using Domain.Objects.Shop;
using MyFrameWork.AppTool;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace App.Object.Shop.CountTypeApp
{
    public class CountTypeApp : CrudService<CountType, CountTypeView, CountTypeCreate, CountTypeView, int>,
                                ICountTypeApp
    {
        private readonly ICountTypeRep _rep;
        private readonly IMapper _mapper;

        public CountTypeApp(ICountTypeRep rep, IMapper mapper)
            : base(rep, mapper)
        {
            _rep = rep;
            _mapper = mapper;
        }

        /*=== CRUD ÛŒÚ©â€ŒØ®Ø·ÛŒ ===*/
        public Task<ApiResult<List<CountTypeView>>> GetAll(Pagination pagination) => base.GetAllAsync(pagination);
        public Task<ApiResult<CountTypeView>> GetById(int id)                   => base.GetByIdAsync(id);
        public Task<ApiResult> Create(CountTypeCreate dto)                      => base.CreateAsync(dto);
        public Task<ApiResult> DeleteBy(List<int> ids)                          => base.DeleteAsync(ids);
        public Task<ApiResult> Update(CountTypeView dto)                        => base.UpdateAsync(dto);
    }

    public interface ICountTypeRep : IBaseRep<CountType, int> { }
}

===== FILE: App\Object\Shop\invApp\InvApp.cs =====
using App.Contracts.Object.Shop.InvCon;
using App.Object.Base;
using App.utility;
using AutoMapper;
using Domain.Objects.Shop;
using MyFrameWork.AppTool;

namespace App.Object.Shop.InvApp
{
    public class InvApp : CrudService<Inv, InvView, InvCreate, InvUpdate, int>,
                          IInvApp
    {
        private readonly IInvRep _invRep;
        private readonly IMapper _mapper;

        public InvApp(IInvRep invRep, IMapper mapper)
            : base(invRep, mapper)
        {
            _invRep = invRep;
            _mapper = mapper;
        }

        public Task<ApiResult<List<InvView>>> GetAll(Pagination pagination) => base.GetAllAsync(pagination);
        public Task<ApiResult<InvUpdate>> GetById(int id)                 => base.GetByIdAsync(id);
        public Task<ApiResult> Create(InvCreate dto)                      => base.CreateAsync(dto);
        public Task<ApiResult> DeleteBy(List<int> ids)                    => base.DeleteAsync(ids);
        public Task<ApiResult> Update(InvUpdate dto)                      => base.UpdateAsync(dto);
    }

    public interface IInvRep : IBaseRep<Inv, int> { }
}

===== FILE: App\Object\Shop\ProductApp\ProductApp.cs =====
using App.Contracts.Object.Shop.ProductCon;
using App.Object.Base;
using App.utility;
using AutoMapper;
using Domain.Objects.Shop;
using MyFrameWork.AppTool;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;

namespace App.Object.Shop.ProductApp
{
    public class ProductApp : CrudService<Product, ProductView, ProductCreate, ProductUpdate, int>,
                              IProductApp
    {
        private readonly IProductRep _productRep;
        private readonly IMapper _mapper;

        public ProductApp(IProductRep productRep, IMapper mapper)
            : base(productRep, mapper)
        {
            _productRep = productRep;
            _mapper = mapper;
        }

        /*=== CRUD یک‌خطی ===*/
        public Task<ApiResult<List<ProductView>>> GetAll(Pagination pagination) => base.GetAllAsync(pagination);
        public Task<ApiResult<ProductUpdate>> GetById(int id) => base.GetByIdAsync(id);
        public Task<ApiResult> Create(ProductCreate dto) => base.CreateAsync(dto);
        public Task<ApiResult> DeleteBy(List<int> ids) => base.DeleteAsync(ids);
        public Task<ApiResult> Update(ProductUpdate dto) => base.UpdateAsync(dto);

        /*=== متد اختصاصی ===*/
        public async Task<ApiResult<List<ProductView>>> SearchProducts(ProductSearchCriteria criteria)
        {
            Expression<Func<Product, bool>> filter = p => true;

            if (!string.IsNullOrWhiteSpace(criteria.Name))
                filter = filter.And(p => p.Name.Contains(criteria.Name));

            if (criteria.MinPrice.HasValue && criteria.MinPrice.Value != 0)
                filter = filter.And(p => p.Price >= criteria.MinPrice.Value);

            if (criteria.MaxPrice.HasValue && criteria.MaxPrice.Value != 0)
                filter = filter.And(p => p.Price <= criteria.MaxPrice.Value);

            var data = await _productRep.GetFilteredAsync(filter, criteria);
            var views = _mapper.Map<List<ProductView>>(data);
            var total = await _productRep.CountAsync(filter);

            return ApiResult<List<ProductView>>.PagedSuccess(views, total,
                                                             criteria.PageNumber,
                                                             criteria.PageSize);
        }
    }

    public interface IProductRep : IBaseRep<Product, int> { }
}

===== FILE: App\Object\BaseService.cs =====
// App\Object\BaseService.cs
using App.Object.Base.Users;
using App.utility;
using AutoMapper;
using Domain.Objects;
using MyFrameWork.AppTool;
using System.Linq.Expressions;

namespace App.Object
{
    public abstract class BaseService<TDto, TCreate, TUpdate, TEntity>
        where TDto : class
        where TCreate : class
        where TUpdate : class
        where TEntity : BaseDomain
    {
        protected readonly IBaseRep<TEntity, int> _repository;
        protected readonly IMapper _mapper;
        protected readonly IFileService? _fileService;
        protected readonly UserStatusService? _statusService;

        protected BaseService(
            IBaseRep<TEntity, int> repository,
            IMapper mapper,
            IFileService? fileService = null,
            UserStatusService? statusService = null)
        {
            _repository = repository;
            _mapper = mapper;
            _fileService = fileService;
            _statusService = statusService;
        }

        // GET ALL + Pagination
        public virtual async Task<ApiResult<List<TDto>>> GetAll(Pagination pagination)
        {
            var entities = await _repository.GetAsync(pagination);
            var dtos = _mapper.Map<List<TDto>>(entities);
            var total = await _repository.CountAsync();

            return ApiResult<List<TDto>>.PagedSuccess(dtos, total, pagination.PageNumber, pagination.PageSize);
        }

        // GET BY ID
        public virtual async Task<ApiResult<TUpdate>> GetById(int id)
        {
            var entity = await _repository.GetAsync(id);
            if (entity == null)
                return ApiResult<TUpdate>.Failed(MessageApp.NotFound, 404);

            var dto = _mapper.Map<TUpdate>(entity);
            return ApiResult<TUpdate>.Success(dto);
        }

        // CREATE
        public virtual async Task<ApiResult> Create(TCreate createDto)
        {
            var entity = _mapper.Map<TEntity>(createDto);

            await BeforeCreate(entity, createDto);
            await _repository.CreateAsync(entity);
            await _repository.SaveChangesAsync();
            await AfterCreate(entity, createDto);

            return ApiResult.Success("Ø±Ú©ÙˆØ±Ø¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯.");
        }

        // UPDATE
        public virtual async Task<ApiResult> Update(TUpdate updateDto)
        {
            var idProp = updateDto.GetType().GetProperty("Id")?.GetValue(updateDto);
            if (idProp is not int id || id <= 0)
                return ApiResult.Failed("Ø´Ù†Ø§Ø³Ù‡ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.", 400);

            var entity = await _repository.GetAsync(id);
            if (entity == null)
                return ApiResult.Failed(MessageApp.NotFound, 404);

            _mapper.Map(updateDto, entity);

            await BeforeUpdate(entity, updateDto);
            await _repository.UpdateAsync(entity);
            await _repository.SaveChangesAsync();
            await AfterUpdate(entity, updateDto);

            return ApiResult.Success("Ø±Ú©ÙˆØ±Ø¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯.");
        }

        // DELETE
        public virtual async Task<ApiResult> DeleteBy(List<int> ids)
        {
            if (!ids.Any())
                return ApiResult.Failed("Ù‡ÛŒÚ† Ø´Ù†Ø§Ø³Ù‡â€ŒØ§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.", 400);

            var entities = await _repository.GetByIdsAsync(ids);
            if (!entities.Any())
                return ApiResult.Failed(MessageApp.NotFound, 404);

            foreach (var entity in entities)
                _repository.Delete(entity);

            await _repository.SaveChangesAsync();
            return ApiResult.Success("Ø±Ú©ÙˆØ±Ø¯(Ù‡Ø§) Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯Ù†Ø¯.");
        }

        // HOOKS â€” Ø¨Ø±Ø§ÛŒ override Ø¯Ø± ÙØ±Ø²Ù†Ø¯
        protected virtual Task BeforeCreate(TEntity entity, TCreate dto) => Task.CompletedTask;
        protected virtual Task AfterCreate(TEntity entity, TCreate dto) => Task.CompletedTask;
        protected virtual Task BeforeUpdate(TEntity entity, TUpdate dto) => Task.CompletedTask;
        protected virtual Task AfterUpdate(TEntity entity, TUpdate dto) => Task.CompletedTask;
    }
}

===== FILE: App\utility\ChatProfile.cs =====
// App/utility/ChatProfile.cs
using App.Contracts.Object.Chat;
using AutoMapper;
using Domain.Objects.Chat;

public class ChatProfile : Profile
{
    public ChatProfile()
    {
        CreateMap<Message, MessageView>();
    }
}

===== FILE: App\utility\ClassMapping.cs =====
// فایل: App/ClassMapping.cs
using App.Contracts.Object.Base.Users;
using App.Contracts.Object.Shop.CountTypeCon;
using App.Contracts.Object.Shop.InvCon;
using App.Contracts.Object.Shop.ProductCon;
using AutoMapper;
using Domain.Objects.Base;
using Domain.Objects.Shop;

namespace App.utility
{
    // این کلاس برای نگاشت (Map) بین مدل‌های دامنه (Entity) و مدل‌های انتقال داده (DTO) استفاده می‌شود
    public class ClassMapping : Profile
    {
        public ClassMapping()
        {
            // نگاشت از مدل دامنه Product به مدل نمایشی ProductView
            CreateMap<Product, ProductView>();

            // نگاشت از مدل ساخت ProductCreate به مدل دامنه Product
            CreateMap<ProductCreate, Product>()
                // ویژگی Id را نادیده می‌گیریم چون در زمان ایجاد توسط دیتابیس مقداردهی می‌شود
                .ForMember(p => p.Id, o => o.Ignore());
            CreateMap<Product, ProductUpdate>();

            // نگاشت از مدل دامنه CountType به مدل نمایشی CountTypeViw
            CreateMap<CountType, CountTypeView>();


            // نگاشت از مدل دامنه CountType به مدل ساخت CountTypeView
            CreateMap<CountTypeView, CountType>();


            // نگاشت از مدل ساخت CountTypeCreate به مدل دامنه CountType
            CreateMap<CountTypeCreate, CountType>()
                // ویژگی Id باید در ساخت جدید مقدار نداشته باشد چون توسط دیتابیس مقداردهی می‌شود
                .ForMember(p => p.Id, o => o.Ignore());


        // مپینگ برای UsersView (برای GetAll) - بدون RoleIds
            CreateMap<User, UsersView>()
            .ForMember(dest => dest.ProfilePictureUrl, opt => opt.MapFrom(src => src.ProfilePictureUrl)); 

            // مپینگ برای UsersUpdate (برای GetById) - شامل RoleIds
            CreateMap<User, UsersUpdate>()
                .ForMember(dest => dest.RoleIds, opt => opt.MapFrom(src => src.UserRoles.Select(ur => ur.RoleId).ToList()))
                .ForMember(dest => dest.ProfilePictureUrl, opt => opt.MapFrom(src => src.ProfilePictureUrl))
                .ForMember(dest => dest.Password, opt => opt.Ignore()); 

            // مپینگ برای UsersCreat به User
            CreateMap<UsersCreat, User>()
                .ForMember(dest => dest.Id, opt => opt.Ignore())
                .ForMember(dest => dest.PasswordHash, opt => opt.MapFrom(src =>
                    string.IsNullOrEmpty(src.Password) ? null : BCrypt.Net.BCrypt.HashPassword(src.Password)))
                .ForMember(dest => dest.UserRoles, opt => opt.MapFrom(src => src.RoleIds.Select(roleId => new UserRole { RoleId = roleId }).ToList()))
                .ForMember(dest => dest.ProfilePictureUrl, opt => opt.MapFrom(src => src.ProfilePictureUrl));

            // مپینگ برای UsersUpdate به User
            CreateMap<UsersUpdate, User>()
                .ForMember(dest => dest.Id, opt => opt.Ignore())
                .ForMember(dest => dest.PasswordHash, opt => opt.MapFrom(src =>
                    string.IsNullOrEmpty(src.Password) ? null : BCrypt.Net.BCrypt.HashPassword(src.Password)))
                .ForMember(dest => dest.UserRoles, opt => opt.MapFrom(src => src.RoleIds.Select(roleId => new UserRole { RoleId = roleId }).ToList()))
                .ForMember(dest => dest.ProfilePictureUrl, opt => opt.MapFrom(src => src.ProfilePictureUrl));

            // مپینگ معکوس (اختیاری، در صورت نیاز)
            CreateMap<User, UsersCreat>()
                .ForMember(dest => dest.RoleIds, opt => opt.MapFrom(src => src.UserRoles.Select(ur => ur.RoleId).ToList()))
                .ForMember(dest => dest.ProfilePictureUrl, opt => opt.MapFrom(src => src.ProfilePictureUrl));


            CreateMap<User,UserList>();


            CreateMap<Inv , InvView>();


        }
    }
}


===== FILE: App\utility\IFileService.cs =====
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using SixLabors.ImageSharp.Processing;

namespace App.utility
{
    public interface IFileService
    {
             Task<string?> UploadAsync(
            IFormFile? file,
            string folderPath,
            string? existingUrl = null,
            ResizeOptions? resizeOptions = null);
    }
}

===== FILE: App\utility\ModelValidator.cs =====
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading.Tasks;
using MyFrameWork.AppTool;

namespace App.utility
{
 public static class ModelValidator
    {
        public static OPT ValidateToOpt<T>(T model)
        {
            var context = new ValidationContext(model, serviceProvider: null, items: null);
            var results = new List<ValidationResult>();

            Validator.TryValidateObject(model, context, results, validateAllProperties: true);

            if (results.Any())
            {
                return new OPT
                {
                    IsSucceeded = false,
                    Message = string.Join(" | ", results.Select(r => r.ErrorMessage))
                };
            }

            return new OPT { IsSucceeded = true }; // Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø¯ÙˆÙ† Ø®Ø·Ø§
        }

        public static OPTResult<T> ValidateToOptResult<T>(T model) where T : class
        {
            var context = new ValidationContext(model, serviceProvider: null, items: null);
            var results = new List<ValidationResult>();

            Validator.TryValidateObject(model, context, results, validateAllProperties: true);

            if (results.Any())
            {
                return new OPTResult<T>
                {
                    IsSucceeded = false,
                    Message = string.Join(" | ", results.Select(r => r.ErrorMessage)),
                    Data = default
                };
            }

            return new OPTResult<T>
            {
                IsSucceeded = true,
               
               
            };
        }
    }
}

===== FILE: App\utility\ValidationUtility.cs =====
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading.Tasks;
using MyFrameWork.AppTool;

namespace App.utility
{
    public static class ValidationUtility
{

     private static readonly OPT opt = new OPT();


    public static OPT ValidateNotEmpty(string value, string fieldName)
    {
        if (string.IsNullOrWhiteSpace(value))
            return opt.Failed($"{fieldName} Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø®Ø§Ù„ÛŒ Ø¨Ø§Ø´Ø¯.");
        return opt.Succeeded();
    }

    public static OPT ValidateLength(string value, string fieldName, int minLength, int maxLength)
    {
        if (value.Length < minLength || value.Length > maxLength)
            return opt.Failed($"{fieldName} Ø¨Ø§ÛŒØ¯ Ø¨ÛŒÙ† {minLength} ØªØ§ {maxLength} Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯.");
        return opt.Succeeded();
    }

    public static OPT ValidateRange(decimal value, string fieldName, decimal minValue, decimal maxValue)
    {
        if (value < minValue || value > maxValue)
            return opt.Failed($"{fieldName} Ø¨Ø§ÛŒØ¯ Ø¨ÛŒÙ† {minValue} ØªØ§ {maxValue} Ø¨Ø§Ø´Ø¯.");
        return opt.Succeeded();
    }

   public static async Task<OPT> ValidateUniqueAsync<T, TKey>(
    IBaseRep<T, TKey> repository, 
    Expression<Func<T, bool>> predicate, 
    string errorMessage)
    where T : Domain.Objects.BaseDomain
{
    var exists = await repository.ExistAsync(predicate);
    if (exists)
        return opt.Failed(errorMessage);
    return opt.Succeeded();
}
}
}

===== FILE: App\IBaseRep.cs =====
using App.Contracts.Object.Shop.ProductCon;
using Domain.Objects;
using MyFrameWork.AppTool;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;

namespace App
{
    public interface IBaseRep<T, TKey> : IDisposable where T : BaseDomain
    {
        Task<T> GetAsync(TKey id);
        T Get(TKey id);
        Task<List<T>>  GetFilteredAsync(Expression<Func<T, bool>> filter = null , ProductSearchCriteria criteria = null);
        Task<List<T>> GetAsync();
        Task<List<T>> GetAsync(Pagination pagination );
        Task CreateAsync(T entity);
        void Delete(T entity);
        void DeleteById(TKey id);
        Task<int> CountAsync();
        Task<int> CountAsync(Expression<Func<T , bool>> filter);
        Task<bool> ExistAsync(Expression<Func<T, bool>> expression  );
        Task<bool> UpdateAsync(T entity);
        Task SaveChangesAsync();
        Task<List<T>> GetByIdsAsync(List<TKey> ids);
        public void DeleteRange(List<T> entities);
        public Task<bool> HasRelationsAsync(T entity);
    }
}


===== FILE: App.Contracts\Attributes\MinCountAttribute.cs =====
// App.Contracts/Attributes/MinCountAttribute.cs
using System;
using System.Collections;
using System.ComponentModel.DataAnnotations;

namespace App.Contracts.Attributes
{
    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]
    public class MinCountAttribute : ValidationAttribute
    {
        private readonly int _minCount;

        public MinCountAttribute(int minCount)
        {
            _minCount = minCount;
            ErrorMessage = $"Ø­Ø¯Ø§Ù‚Ù„ {{0}} Ù…ÙˆØ±Ø¯ Ø¨Ø§ÛŒØ¯ Ø§Ù†ØªØ®Ø§Ø¨ Ø´ÙˆØ¯.";
        }

        protected override ValidationResult? IsValid(object? value, ValidationContext validationContext)
        {
            if (value == null)
                return new ValidationResult(FormatErrorMessage(validationContext.DisplayName));

            if (value is IList list)
            {
                if (list.Count < _minCount)
                    return new ValidationResult(FormatErrorMessage(validationContext.DisplayName));
            }
            else
            {
                return new ValidationResult("Ø§ÛŒÙ† ÙÛŒÙ„Ø¯ Ø¨Ø§ÛŒØ¯ ÛŒÚ© Ù„ÛŒØ³Øª Ø¨Ø§Ø´Ø¯.");
            }

            return ValidationResult.Success;
        }

        public override string FormatErrorMessage(string name)
        {
            return string.Format(ErrorMessageString, _minCount);
        }
    }
}

===== FILE: App.Contracts\Object\Base\auth\UserContext\IUserContext.cs =====
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace App.Contracts.Object.Base.auth.UserContext
{
    public interface IUserContext
    {
        int? GetUserId();
        bool IsAuthenticated();
        // Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒ Ù…ØªØ¯Ù‡Ø§ÛŒ Ø¯ÛŒÚ¯Ù‡â€ŒØ§ÛŒ Ù…Ø«Ù„ GetUserRoles ÛŒØ§ GetClaim Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒ
    }
}

===== FILE: App.Contracts\Object\Base\auth\AuthResponseDto.cs =====
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Domain.Objects.Base;
using MyFrameWork.AppTool;

namespace App.Contracts.Object.Base.auth
{
    public class AuthResponseDto
    {
        public int UserId { get; set; } = default! ;
        public string Token { get; set; } = default!;
        public string Username { get; set; } = default!;
        public string FullName { get; set; } = default!;
        
    }

     public class LoginRequestDto
    {
        public string Username  { get; set; } = default!;
        public string Password { get; set; } = default!;
    }

        public class RegisterRequestDto
    {
        public string FullName { get; set; } = default!;
        public string Username { get; set; } = default!;
        public string Password { get; set; } = default!;
    }

      public interface IAuthApp
    {
         Task<ApiResult<AuthResponseDto>>  RegisterAsync(RegisterRequestDto dto);
        Task<ApiResult<AuthResponseDto>> LoginAsync(LoginRequestDto dto);
        
    }

     public interface ITokenApp
    {
        string GenerateToken(User user);
    }
}

===== FILE: App.Contracts\Object\Base\auth\IPermissionDiscoveryService.cs =====
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace App.Contracts.Object.Base.auth
{
    public interface IPermissionDiscoveryService
    {
        IEnumerable<string> GetAllPermissionNames();
    }
}

===== FILE: App.Contracts\Object\Base\auth\IPermissionService.cs =====
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace App.Contracts.Object.Base.auth
{
    public interface IPermissionService
    {
        Task<bool> HasPermissionAsync(int userId, string permission);
        Task<List<string>> GetUserPermissionsAsync(int userId);
    }
}

===== FILE: App.Contracts\Object\Base\Users\IUsersApp.cs =====
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using MyFrameWork.AppTool;

namespace App.Contracts.Object.Base.Users
{
public interface IUsersApp
    {
Task<ApiResult<List<UsersView>>>             GetAll(Pagination pagination);
        Task<ApiResult<UsersUpdate>>         GetById(int id);
        Task<ApiResult>                      CreateAsync(UsersCreat dto);
        Task<ApiResult>                      UpdateAsync(UsersUpdate dto);
        Task<ApiResult>                      DeleteBy(List<int> ids);
        Task<ApiResult<UserCreateFormData>>  CreateForm();
        Task<ApiResult>                      KeepAlive(int userId);
        Task<ApiResult<List<UserList>>>      GetList();
    }
}

===== FILE: App.Contracts\Object\Base\Users\UsersDto.cs =====
// App.Contracts/Object/Base/Users/UsersDto.cs
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using Microsoft.AspNetCore.Http;
using Domain.Objects.Base;
using App.Contracts.Attributes; // Ø¨Ø±Ø§ÛŒ MinCount

namespace App.Contracts.Object.Base.Users
{
    public class UsersView
    {
        public int Id { get; set; }
        public string FullName { get; set; } = default!;
        public string? ProfilePictureUrl { get; set; }
        public UserStatus Status { get; set; }
        public DateTime? LastSeen { get; set; }
        public string Username { get; set; } = default!;
        public string Email { get; set; } = default!;
    }

    public class UsersCreat
    {

        public string FullName { get; set; } = default!;


        public string Username { get; set; } = default!;


        public string Email { get; set; } = default!;

        public string Password { get; set; } = default!;

        public IFormFile? ProfilePicture { get; set; }

        public string? ProfilePictureUrl { get; set; }


        public List<int>? RoleIds { get; set; } = new();
    }

    public class UsersUpdate
    {
        [Required]
        public int Id { get; set; }


        public string FullName { get; set; } = default!;


        public string Username { get; set; } = default!;


        public string Email { get; set; } = default!;


        public string? Password { get; set; }

        public IFormFile? ProfilePicture { get; set; }

        public string? ProfilePictureUrl { get; set; }

        public List<int>? RoleIds { get; set; } = new();
    }
    public class UserList
    {
        public int Id { get; set; }
        public string FullName { get; set; } = default!;


    }
    public class UserCreateFormData
    {
        public List<RoleView> Roles { get; set; } = new();
    }

    public class RoleView
    {
        public int Id { get; set; }
        public string Name { get; set; } = default!;
    }
}

===== FILE: App.Contracts\Object\Base\IPersonApp.cs =====
namespace App.Contracts.Object.Base
{
    public interface IPersonApp
    {
        Task<List<PersonView>> PersonViews();
    }
}


===== FILE: App.Contracts\Object\Base\PersonView.cs =====
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace App.Contracts.Object.Base
{
    public class PersonView
    {
        [Required]
        public int Id { get; set; }

        [Required]
        [StringLength(3)]
        public string Name { get; set; }

        [Required]
        [StringLength(3)]
        public string Family { get; set; }

        [Required]
        public int age { get; set; }
    }
}


===== FILE: App.Contracts\Object\Chat\IChatApp.cs =====
// App.Contracts/Object/Chat/IChatApp.cs
using MyFrameWork.AppTool;

namespace App.Contracts.Object.Chat
{
    public interface IChatApp
    {
        Task<ApiResult<MessageView>> SendMessageAsync(SendMessageDto dto, int senderId);
        Task<ApiResult<List<MessageView>>> GetChatHistoryAsync(int otherUserId, Pagination pagination, int currentUserId);
        Task<ApiResult<List<ChatListItem>>> GetChatListAsync(int userId);
        Task<ApiResult> MarkAsReadAsync(int senderId, int receiverId);
        Task<ApiResult<int>> GetTotalUnreadCountAsync(int receiverId);
    }
}

===== FILE: App.Contracts\Object\Chat\SendMessageDto.cs =====
// App.Contracts/Object/Chat/SendMessageDto.cs
using Microsoft.AspNetCore.Http;
using Domain.Objects.Chat;

namespace App.Contracts.Object.Chat
{
    public class SendMessageDto
    {
        public int ReceiverId { get; set; }
        public string Content { get; set; } = string.Empty;
        public IFormFile? File { get; set; }
        public MessageType Type { get; set; } = MessageType.Text;
    }




    public class MessageView
    {
        public int Id { get; set; }
        public int SenderId { get; set; }
        public string SenderName { get; set; } = string.Empty;
        public string Content { get; set; } = string.Empty;
        public string? FileUrl { get; set; }
        public MessageType Type { get; set; }
        public DateTime SentAt { get; set; }
        public DateTime? DeliveredAt { get; set; }
        public DateTime? SeenAt { get; set; }
        public bool IsMine { get; set; } // Ø¨Ø±Ø§ÛŒ UI
    }

    public class ChatListItem
    {
        public int UserId { get; set; }
        public string UserName { get; set; } = string.Empty;
        public string? LastMessage { get; set; }
        public DateTime? LastMessageTime { get; set; }
        public int UnreadCount { get; set; }
        public bool IsOnline { get; set; }
        public DateTime? LastSeen { get; set; }
    }
}

===== FILE: App.Contracts\Object\Shop\CountTypeCon\CountTypeView.cs =====
using MyFrameWork.AppTool;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Text.Json.Nodes;
using System.Threading.Tasks;

namespace App.Contracts.Object.Shop.CountTypeCon
{
    public class CountTypeView
    {
        [Display(Name = " Ø´Ù†Ø§Ø³Ù‡")]
        public int Id { get; set; }
    
        [Display(Name = " Ù†Ø§Ù… ÙˆØ§Ø­Ø¯ Ø´Ù…Ø§Ø±Ø´")]
        public string Name { get; set; } = "";
        

    }
    public class CountTypeCreate 
    {

        
    
        [Display(Name = " Ù†Ø§Ù… ÙˆØ§Ø­Ø¯ Ø´Ù…Ø§Ø±Ø´")]
        [Required(ErrorMessage = MessageApp.IsRequiredcustom)]
        [MaxLength(20,ErrorMessage = MessageApp.MaxLengthcustom)]
        [RegularExpression(@"^[\u0600-\u06FF\s]+$", ErrorMessage = "ÙÙ‚Ø· Ø§Ø² Ø­Ø±ÙˆÙ ÙØ§Ø±Ø³ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯")]
        [DataType(DataType.Text)]
        public string Name { get; set; } = "";
       
       

    }
    
   

}


===== FILE: App.Contracts\Object\Shop\CountTypeCon\ICountTypeApp.cs =====
using MyFrameWork.AppTool;


namespace App.Contracts.Object.Shop.CountTypeCon
{
    public interface ICountTypeApp
    {
        public Task<ApiResult<List<CountTypeView>>> GetAll(Pagination pagination);
        public Task<ApiResult<CountTypeView>> GetById(int id);
        public Task<ApiResult> Create(CountTypeCreate dto);
        public Task<ApiResult> DeleteBy(List<int> ids);
        public Task<ApiResult> Update(CountTypeView dto);
    

    }

}


